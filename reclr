#!/bin/sh
# reclr - minimal palette loader and template expander

die() {
    printf 'error: %s\n' "$*" >&2
    exit 1
}

# convert hex digit to decimal
h2d() {
    case $1 in
        [0-9]) printf '%d' "$1" ;;
        [aA]) printf 10 ;; [bB]) printf 11 ;; [cC]) printf 12 ;;
        [dD]) printf 13 ;; [eE]) printf 14 ;; [fF]) printf 15 ;;
    esac
}

# convert hex pair to decimal
h2p() {
    # ${1%?} removes last char, ${1#?} removes first char
    printf '%d' "$(($(h2d ${1%?}) * 16 + $(h2d ${1#?})))"
}

# convert #rrggbb to r,g,b
hex2rgb() {
    h=${1#\#}
    printf '%d,%d,%d' \
        "$(h2p ${h%????})" \  # keeps first 2 chars
        "$(h2p $(printf '%s' "$h" | cut -c3-4))" \  # gets middle 2
        "$(h2p ${h#????})"  # keeps last 2
}

# rgb to hex
rgb2hex() {
    printf '#%02x%02x%02x' "$1" "$2" "$3"
}

# get perceived brightness (0-255)
brightness() {
    h=${1#\#}
    r=$(h2p ${h%????})
    g=$(h2p $(printf '%s' "$h" | cut -c3-4))
    b=$(h2p ${h#????})
    printf '%d' $(( (r*299 + g*587 + b*114) / 1000 ))
}

# darken/lighten color by percentage (in HCL-like space)
adjust() {
    h=${1#\#}
    r=$(h2p ${h%????})
    g=$(h2p $(printf '%s' "$h" | cut -c3-4))
    b=$(h2p ${h#????})
    
    case $2 in
        -*) # darken
            p=${2#-}
            r=$(( r * (100 - p) / 100 ))
            g=$(( g * (100 - p) / 100 ))
            b=$(( b * (100 - p) / 100 ))
            ;;
        *) # lighten
            r=$(( r + (255 - r) * $2 / 100 ))
            g=$(( g + (255 - g) * $2 / 100 ))
            b=$(( b + (255 - b) * $2 / 100 ))
            ;;
    esac
    
    [ "$r" -gt 255 ] && r=255; [ "$r" -lt 0 ] && r=0
    [ "$g" -gt 255 ] && g=255; [ "$g" -lt 0 ] && g=0
    [ "$b" -gt 255 ] && b=255; [ "$b" -lt 0 ] && b=0
    
    rgb2hex "$r" "$g" "$b"
}

# extract colors from image using imagemagick (pywal method)
extract_colors() {
    command -v convert >/dev/null 2>&1 || die "imagemagick required for -g"
    [ -f "$1" ] || die "image not found: $1"
    
    # pywal method: resize, quantize to 16+ colors, get unique colors
    # try increasing palette size until we get >16 colors
    i=0
    while [ "$i" -lt 20 ]; do
        n=$((16 + i))
        cols=$(convert "$1" -resize 256x256 -colors "$n" -unique-colors txt:- 2>/dev/null | \
            grep -o '#[0-9A-Fa-f]\{6\}')
        
        [ "$(printf '%s\n' "$cols" | wc -l)" -gt 16 ] && break
        i=$((i + 1))
    done
    
    [ -z "$cols" ] && die "failed to extract colors"
    printf '%s\n' "$cols"
}

# generate palette from image (pywal algorithm)
gen_pal() {
    img=$1
    out=$2
    
    printf 'generating palette from %s...\n' "$img"
    
    # extract colors
    raw=$(extract_colors "$img")
    [ -z "$raw" ] && die "no colors extracted"
    
    # pywal rearranges: [0] + [8:16] + [8:-1]
    # this gives: bg, then 8 bright colors, then 8 darker variants
    all=$(printf '%s\n' "$raw")
    
    # get background (darkest color)
    bg=$(printf '%s\n' "$all" | head -n1)
    bg_br=$(brightness "$bg")
    
    # determine if light/dark theme
    if [ "$bg_br" -lt 128 ]; then
        # dark theme: use lightest as fg
        fg=$(printf '%s\n' "$all" | tail -n1)
    else
        # light theme: swap bg/fg
        fg=$bg
        bg=$(printf '%s\n' "$all" | tail -n1)
    fi
    
    # take colors 2-17 (skip first bg)
    colors=$(printf '%s\n' "$all" | tail -n +2 | head -n16)
    
    # split into color0-7 (darker) and color8-15 (brighter)
    # pywal uses: colors[8:16] for 0-7, colors[8:-1] for 8-15
    c0_7=$(printf '%s\n' "$colors" | tail -n8)
    c8_15=$(printf '%s\n' "$colors" | head -n8)
    
    # write palette
    mkdir -p "${out%/*}" 2>/dev/null
    {
        printf 'background=%s\n' "$bg"
        printf 'foreground=%s\n' "$fg"
        
        i=0
        printf '%s\n' "$c0_7" | while read -r c && [ "$i" -lt 8 ]; do
            [ -n "$c" ] && printf 'color%d=%s\n' "$i" "$c"
            i=$((i+1))
        done
        
        i=8
        printf '%s\n' "$c8_15" | while read -r c && [ "$i" -lt 16 ]; do
            [ -n "$c" ] && printf 'color%d=%s\n' "$i" "$c"
            i=$((i+1))
        done
    } > "$out"
    
    printf 'palette saved to %s\n' "$out"
}

# find palette in search dirs
find_pal() {
    for d in $pdir; do
        [ -d "$d" ] || continue
        result=$(find "$d" -type f -name "$1.txt" 2>/dev/null | head -n1)
        [ -n "$result" ] && { printf '%s' "$result"; return 0; }
    done
    return 1
}

# load palette into p_* vars
load_pal() {
    [ -f "$1" ] || die "palette not found: $1"

    while IFS='=' read -r k v || [ -n "$k" ]; do
        # trim leading and trailing spaces
        k=${k#"${k%%[![:space:]]*}"}; k=${k%"${k##*[![:space:]]}"}
        v=${v#"${v%%[![:space:]]*}"}; v=${v%"${v##*[![:space:]]}"}
        [ -z "$k" ] && continue
        eval "p_$k=\"$v\""
    done < "$1"

    for k in background foreground color0 color1 color2 color3 \
             color4 color5 color6 color7 color8 color9 color10 \
             color11 color12 color13 color14 color15; do
        eval "[ -z \"\$p_$k\" ]" && die "missing key: $k"
    done

    # set fallbacks for optional colors
    [ -z "$p_accent" ] && p_accent="$p_color2"
    [ -z "$p_cursor" ] && p_cursor="$p_color15"

    printf 'reclr: set palette to %s\n' "${1##*/}"
}

# process placeholder (var or var.mod)
proc_ph() {
    eval "v=\$p_$1"
    case $2 in
        strip) printf '%s' "${v#\#}" ;;
        rgb) hex2rgb "$v" ;;
        *) printf '%s' "$v" ;;
    esac
}

# expand single line
expand_ln() {
    r=$1
    while [ "${r#*\{*\}}" != "$r" ]; do  # check for complete {..} pair
        pre=${r%%\{*}                     # text before {
        mid=${r#*\{}; mid=${mid%%\}*}     # placeholder between {}
        post=${r#*\}}                     # text after }
        
        case $mid in
            *.*) val=$(proc_ph "${mid%%.*}" "${mid#*.}") ;;  # var.mod
            *)   val=$(proc_ph "$mid" '') ;;                 # var only
        esac
        
        r="$pre$val$post"
    done
    printf '%s\n' "$r"
}

# expand template file
expand_tmpl() {
    out=$2
    mkdir -p "${out%/*}" 2>/dev/null || die "mkdir failed: ${out%/*}"
    : > "$out" || die "cannot write: $out"
    
    while IFS= read -r l || [ -n "$l" ]; do
        expand_ln "$l" >> "$out"
    done < "$1"
}

# expand all templates from template dirs
expand_all() {
    for td in $tdir; do
        [ -d "$td" ] || continue
        for tm in "$td"/*; do
            [ -f "$tm" ] || continue
            rel=${tm#"$td"}
            rel=${rel#/}
            out="$odir/$rel"
            [ -f "$out" ] && continue
            expand_tmpl "$tm" "$odir/$rel"
        done
    done
}

# generate and apply terminal sequences
apply_seqs() {
    : > "$1" || die "cannot write: $1"
    
    i=0
    while [ "$i" -le 15 ]; do
        eval "c=\$p_color$i"
        printf '\033]4;%d;%s\033\\' "$i" "$c" >> "$1"
        i=$((i + 1))
    done
    
    for code in "10;$p_foreground" "11;$p_background" "12;$p_foreground" \
                "13;$p_foreground" "17;$p_foreground" "19;$p_background" \
                "4;232;$p_background" "4;256;$p_foreground" \
                "4;257;$p_background" "708;$p_background"; do
        printf '\033]%s\033\\' "$code" >> "$1"
    done
    
    for tty in /dev/pts/[0-9]*; do
        [ -w "$tty" ] && cat "$1" > "$tty" 2>/dev/null &
    done
    wait
}

# list available palettes
list_pal() {
    for d in $pdir; do
        [ -d "$d" ] || continue
        find "$d" -type f -name "*.txt" 2>/dev/null | 
            while read -r f; do printf '%s\n' "${f##*/}"; done
    done | sed 's/\.txt$//' | sort -u
}

# preview palette
show_pal() {
    i=0
    while [ "$i" -lt 16 ]; do
        printf "\033[48;5;%sm   \033[0m" "$i"
        [ $(( (i+1) % 8 )) -eq 0 ] && printf "\n"
        i=$((i+1))
    done
}

usage() {
    cat <<EOF
usage: reclr -i palette [-t dir] [-o dir] [-l] [-p] [-h]
       reclr -g image [-n name] [-o dir]

flags:
  -i  load palette by name or path
  -g  generate palette from image
  -n  name for generated palette (default: image basename)
  -t  template directory
  -o  output directory
  -l  list available palettes
  -p  preview current terminal colors
  -h  show this help
EOF
}

main() {
    pdir="${XDG_CONFIG_HOME:-$HOME/.config}/reclr/palettes /etc/reclr/palettes ./palettes"
    tdir="${XDG_CONFIG_HOME:-$HOME/.config}/reclr/templates /etc/reclr/templates ./templates"
    odir="${XDG_CACHE_HOME:-$HOME/.cache}/reclr"
    pal="" gen_img="" gen_name="" default_tdir="$tdir" do_list=0 do_show=0

    while getopts ":i:g:n:t:o:lph" opt; do
        case $opt in
            i) pal=$OPTARG ;;
            g) gen_img=$OPTARG ;;
            n) gen_name=$OPTARG ;;
            t) tdir=$OPTARG ;;
            o) odir=$OPTARG ;;
            l) do_list=1 ;;
            p) do_show=1 ;;
            h) usage; exit 0 ;;
            \?) usage; die "unknown flag: -$OPTARG" ;;
            :) usage; die "missing argument for -$OPTARG" ;;
        esac
    done
    shift $((OPTIND - 1))

    [ "$do_list" -eq 1 ] && list_pal
    [ "$do_show" -eq 1 ] && show_pal
    [ "$do_list" -eq 1 ] || [ "$do_show" -eq 1 ] && [ -z "$pal" ] && [ -z "$gen_img" ] && exit 0

    # handle generation mode
    if [ -n "$gen_img" ]; then
        [ -z "$gen_name" ] && gen_name="${gen_img##*/}"
        gen_name="${gen_name%.*}"
        paldir="${XDG_CONFIG_HOME:-$HOME/.config}/reclr/palettes"
        mkdir -p "$paldir" 2>/dev/null || die "cannot create: $paldir"
        gen_pal "$gen_img" "$paldir/$gen_name.txt"
        pal="$gen_name"
    fi

    [ -z "$pal" ] && { usage; die "no palette specified, use -i or -g"; }

    case $pal in
        /*) pf=$pal ;;
        *) pf=$(find_pal "$pal") || die "palette not found: $pal" ;;
    esac

    load_pal "$pf"
    rm -rf "$odir"/* 2>/dev/null
    mkdir -p "$odir" 2>/dev/null || die "cannot create: $odir"

    apply_seqs "$odir/sequences"
    expand_all

    [ "$tdir" != "$default_tdir" ] && printf 'templates: %s\n' "$tdir"
    printf 'export: %s\n' "$odir"
}

main "$@"
